<div class="row justify-content-center mb-4">
	<div class="col-md-10">
		<div class="card shadow-sm">
			<div class="card-header d-flex justify-content-between align-items-center">
				<span>Live Measurements</span>
				<div class="d-flex align-items-center gap-3">
					<div class="input-group input-group-sm" style="width: 150px;">
						<input type="number" min="1" max="60" step="1" id="chartInterval" class="form-control form-control-sm" title = "secs within [1, 60]" />
						<button class="btn btn-outline-primary btn-sm" title = "Set Chart Update Interval in secs." onclick="applyChartInterval()">Set Interval</button>
					</div>
					<button class="btn btn-sm btn-outline-primary" title="Save Chart Screenshot" onclick="downloadImage()">Save Image</button>
					<button class="btn btn-sm btn-outline-success" title="Save Chart Data in CSV Format" onclick="downloadCSV()">Save CSV</button>
				</div>
			</div>
			<div class="card-body">
				<canvas id="liveChart" height="150"></canvas>
			</div>
		</div>
	</div>
</div>

<div class="row justify-content-center mb-3">
  <div class="col-md-10">
    <div class="card card-body" id="trackTogglePanel">
      <h6 class="mb-3">Toggle Gas Components</h6>
      <div id="trackToggles" class="d-flex flex-wrap gap-3"></div>
    </div>

    <div id="liveNotice" class="small text-muted mt-2" role="status" aria-live="polite"></div>
  </div>
</div>

<script>
	let trackVisibility = {};
	let lastStamp = null;          // ← remember last device timestamp we plotted
  	const MAX_POINTS = 100;        // ← keep the same cap you used implicitly

    const ctx = document.getElementById('liveChart').getContext('2d');
    const liveChart = new Chart(ctx, {
		type: 'line', data: { labels: [], datasets: [] },
		options: {
			responsive: true,
			animation: false,
			scales: {
				x: { title: { display: true, text: 'Time' } },
				y: { title: { display: true, text: 'PPM' }, beginAtZero: true }
			},
			plugins: {
				zoom: {
					zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
					pan: { enabled: true, mode: 'x' }
				},
				legend: {
					onClick: function (e, legendItem, legend) {
						const index = legendItem.datasetIndex;
						const chart = legend.chart;
						const label = chart.data.datasets[index].label;

						// Toggle visibility
						const meta = chart.getDatasetMeta(index);
						meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
						chart.update();

						trackVisibility[label] = chart.isDatasetVisible(index);

						// Update matching checkbox
						const checkbox = document.getElementById(`track-toggle-${index}`);
						if (checkbox) {
							checkbox.checked = trackVisibility[label];
						}

						// update server side config file
						safeFetch(API_PATHS.settings.update, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ track_visibility: trackVisibility })
						});
					}
				}
			}
		}
    });

	function renderTrackToggles() {
		const container = document.getElementById("trackToggles");
		container.innerHTML = ""; // clear before render

		liveChart.data.datasets.forEach((ds, i) => {
			const label = ds.label;
			const id = `track-toggle-${i}`;
			const checked = !ds.hidden;

			const div = document.createElement("div");
			div.classList.add("form-check", "form-switch");

			div.innerHTML = `
				<input class="form-check-input" type="checkbox" role="switch" id="${id}" ${checked ? 'checked' : ''}>
				<div style="display: flex; align-items: center; gap: 6px;">
					<span style="width: 12px; height: 12px; background: ${ds.borderColor}; display: inline-block; border-radius: 2px;"></span>
					<label class="form-check-label" for="${id}" style="color: ${ds.borderColor}; margin: 0;">${label}</label>
				</div>
				`;

			div.querySelector("input").addEventListener("change", (e) => {
				const visible = e.target.checked;
				liveChart.data.datasets[i].hidden = !visible;
				trackVisibility[label] = visible;
				liveChart.update();

				// Save preference
				safeFetch(API_PATHS.settings.update, {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ track_visibility: trackVisibility })
				});
			});

			container.appendChild(div);
		});
	}

	function fetchData() {
		// One line to unify real/dummy without repeating code:
    	const dataUrlDummy = API_PATHS.data && API_PATHS.data.dummy;
		const dataUrlLive = API_PATHS.data && API_PATHS.data.live;
		// safeFetch(API_PATHS.data.dummy).then(res => res.json()).then(data => {
		safeFetch(dataUrlLive).then(res => res.json()).then(data => {
			// Non-data message from server → show one line and skip this tick
			if (!data || data.message) {
				const el = document.getElementById('liveNotice');
				if (el) el.textContent = data && data.message ? data.message : 'No data';
				return;
			} else {
				const el = document.getElementById('liveNotice');
				if (el) el.textContent = '';
			}
			
			const ts = data.timestamp;
			if (typeof ts !== "number") return; // safety

			// Build label from device timestamp (not browser now())
			const label = new Date(ts * 1000).toLocaleTimeString('en-GB', {
				hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
			});

			const isDuplicate = (lastStamp !== null && ts === lastStamp);
			let addedDataset = false;

			if (!isDuplicate) {
				// new measurement moment → push a new label
				liveChart.data.labels.push(label);
				if (liveChart.data.labels.length > MAX_POINTS) liveChart.data.labels.shift();

				// extend each existing dataset with a null placeholder for this moment
				liveChart.data.datasets.forEach(ds => {
					ds.data.push(null);
					if (ds.data.length > MAX_POINTS) ds.data.shift();
				});
			}

			// index of the "current" slot (last label)
			const idx = liveChart.data.labels.length - 1;

			// Upsert values for all reported components
			data.components.forEach(c => {
				let ds = liveChart.data.datasets.find(d => d.label === c.label);
				if (!ds) {
					// new gas track appears → align its length with labels and set style/visibility
					ds = {
						label: c.label,
						data: new Array(liveChart.data.labels.length).fill(null),
						hidden: trackVisibility[c.label] === false,
						borderColor: c.color || undefined,
						backgroundColor: c.color || undefined,
						tension: 0.3
					};
					
					liveChart.data.datasets.push(ds);
					addedDataset = true;
				}
				// write the current ppm into the current slot.
				// if duplicate, this overwrites the last value; if new timestamp, it replaces the null we just pushed.
				ds.data[idx] = c.ppm;
			});

			if (addedDataset) renderTrackToggles();

			lastStamp = ts;

			liveChart.update();
		});
	}

	function downloadImage() {
		const link = document.createElement('a');
		link.href = liveChart.toBase64Image();
		const now = new Date();
		const timestamp = now.toISOString().replace(/[:T-]/g, '_').split('.')[0]; // e.g., 2025_07_19_14_32_01
		link.download = `gasera_chart_${timestamp}.png`;
		link.click();
    }

	function downloadCSV() {
		if (liveChart.data.datasets.length === 0) return;

		let csv = 'Time,' + liveChart.data.datasets.map(d => d.label).join(',') + '\n';
		for (let i = 0; i < liveChart.data.labels.length; i++) {
			const row = [liveChart.data.labels[i]];
			liveChart.data.datasets.forEach(ds => row.push(ds.data[i] ?? ""));
			csv += row.join(',') + '\n';
		}

		const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8' });
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		const now = new Date();
		const timestamp = now.toISOString().replace(/[:T-]/g, '_').split('.')[0]; // e.g., 2025_07_19_14_32_01
		link.download = `gasera_data_${timestamp}.csv`;
		link.click();
	}
	
	let updateTimer = null;

	function setChartUpdateInterval(ms) {
		if (updateTimer) clearInterval(updateTimer);
		const updateInterval = 1000 * ms;
		updateTimer = setInterval(fetchData, updateInterval);
	}

	function applyChartInterval() {
		const value = parseInt(document.getElementById("chartInterval").value);
		if (isNaN(value) || value < 1 || value > 60) {
			alert("Please enter a value between 1 and 60 sec.");
			return;
		}

		safeFetch(API_PATHS.settings.update, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({ chart_update_interval: value })
		})
		.then(res => res.json())
		.then(data => {
			if (data.ok) {
				setChartUpdateInterval(value);
				alert("Chart interval updated.");
			} else {
				alert("Error: " + data.error);
			}
		});
	}

	// Initial fetch
	safeFetch(API_PATHS.settings.read)
		.then(res => res.json())
		.then(data => {
			const interval = data.chart_update_interval || 5;
			document.getElementById("chartInterval").value = interval;
			setChartUpdateInterval(interval);
			trackVisibility = data.track_visibility || {};
	});

	fetchData();
	// dataFetchTimers.push(setInterval(fetchData, 5000));
	setTimeout(renderTrackToggles, 1000); // Give chart a second to initialize datasets

</script>
